<div class="container">
    <div class="page-header">
        <h1 class="page-title">My Timesheet</h1>
        <p class="page-subtitle">Track your work hours and productivity</p>
    </div>

    <!-- Dashboard Cards -->
    <div class="dashboard-cards">
        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-sign-in-alt"></i>
            </div>
            <div class="card-content">
                <h4>Today's Login</h4>
                <p class="card-value"><%= clockInTime ? clockInTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'N/A' %></p>
            </div>
        </div>

        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-clock"></i>
            </div>
            <div class="card-content">
                <h4>Hours Today <i class="fas fa-info-circle" title="Shows total hours worked today (including all clock-ins) and remaining time in your 8-hour shift"></i></h4>
                <div class="countdown-container">
                    <div class="hours-display">
                        <div class="hours-row">
                            <span class="hours-label">Worked:</span>
                            <span id="hours-worked" class="hours-value" data-hours-worked="<%= hoursWorkedRaw || 0 %>">
                                <%= hoursWorkedToday || '0h 0m' %>
                            </span>
                        </div>
                        <div class="hours-row">
                            <span class="hours-label">Remaining:</span>
                            <span id="hours-remaining" class="hours-value" data-remaining-hours="<%= remainingHoursRaw || 8 %>">
                                <%= remainingHoursToday || '8h 0m' %>
                            </span>
                        </div>
                        <!-- Progress Bar (relies on data attributes and JS) -->
                        <div class="progress-bar-container">
                            <div id="work-progress-bar" class="progress-bar" style="width: <%= Math.min(100, Math.max(0, ((hoursWorkedRaw || 0) / 8) * 100)) %>%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-calendar"></i>
            </div>
            <div class="card-content">
                <h4>This Week</h4>
                <p class="card-value">32.5 hrs / 40 hrs</p>
            </div>
        </div>
    </div>

    <!-- Timer Display Section -->
    <div class="timer-section card mb-4">
        <div class="card-body">
            <h5 class="card-title">Today's Progress (All Clock-ins)</h5>
            <div class="timer-display">
                <div class="timer-item">
                    <span class="timer-label">Worked:</span>
                    <span id="timer-hours-worked" class="timer-value"><%= hoursWorkedToday || '0h 0m' %></span>
                    <!-- Hidden data attribute for initialization -->
                    <span id="hours-worked-data" data-total-hours-worked="<%= hoursWorkedRaw || 0 %>" style="display: none;"></span>
                </div>
                <div class="timer-item">
                    <span class="timer-label">Remaining:</span>
                    <span id="countdown-timer" class="timer-value"><%= remainingHoursToday || '8h 0m' %></span>
                </div>
            </div>
            <div class="progress-bar-container mt-3">
                <div class="progress" style="height: 10px;">
                    <div class="progress-bar timer-bar" role="progressbar" style="width: <%= Math.min(100, Math.max(0, ((hoursWorkedRaw || 0) / 8) * 100)) %>%;" aria-valuenow="<%= hoursWorkedRaw || 0 %>" aria-valuemin="0" aria-valuemax="8"></div>
                </div>
            </div>
            <!-- Elements for Server-Side Data (optional but good practice) -->
            <span data-server-hours-worked="<%= hoursWorkedRaw || 0 %>" style="display: none;"></span>
            <span data-server-remaining-hours="<%= remainingHoursRaw || 8 %>" style="display: none;"></span>
        </div>
    </div>

    <!-- Time Tracking Panel -->
    <div class="time-tracking-panel card">
        <div class="panel-header">
            <h3>Time Tracking</h3>
            <div class="status-indicator <%= activeEntry ? 'active' : 'inactive' %>">
                <span class="status-dot"></span>
                <span class="status-text"><%= activeEntry ? 'Working' : 'Not Working' %></span>
            </div>
        </div>
        <div class="panel-body">
            <p>Your current status: <span id="statusText">Loading...</span></p>
            <p>Clocked in at: <span id="clockInTime">--:--</span></p>
            <p>Total Break Time: <span id="totalBreakTime">0 mins</span></p>
            <div class="tracking-actions">
                <button id="clockInBtn" class="btn btn-success">Clock In</button>
                <button id="clockOutBtn" class="btn btn-danger" disabled>Clock Out</button>
                <button id="startBreakBtn" class="btn btn-secondary" disabled>Start Break</button>
                <button id="endBreakBtn" class="btn btn-secondary" disabled>End Break</button>
                <button id="startUnavailableBtn" class="btn btn-primary" disabled>Go Unavailable</button>
                <button id="endUnavailableBtn" class="btn btn-primary" disabled>Go Available</button>
            </div>
        </div>
    </div>

    <!-- Timesheet Controls -->
    <div class="timesheet-controls">
        <div class="control-panel card">
            <div class="panel-header">
                <h3>View Timesheet</h3>
            </div>
            <div class="panel-body">
                <div class="period-selector">
                    <label class="selector-label">Select Period</label>
                    <div class="period-options">
                        <div class="btn btn-primary btn-block btn-tiny" data-period="current-week">Current Week</div>
                        <div class="btn btn-primary btn-block btn-tiny" data-period="last-week">Last Week</div>
                        <div class="btn btn-primary btn-block btn-tiny" data-period="current-month">Current Month</div>
                        <div class="btn btn-primary btn-block btn-tiny" data-period="custom">Custom</div>
                    </div>

                    <div class="custom-dates" style="display: none;">
                        <div class="date-input">
                            <label class="date-label">Start Date</label>
                            <input type="date" class="date-field" id="start-date">
                        </div>
                        <div class="date-input">
                            <label class="date-label">End Date</label>
                            <input type="date" class="date-field" id="end-date">
                        </div>
                    </div>
                </div>

                <div class="filter-section">
                    <h4 class="filter-title">Filter By</h4>
                    <div class="filter-options">
                        <div class="btn btn-primary btn-block btn-tiny gradient-parent"><i class="text-success fas fa-check-circle"></i> Approved</div>
                        <div class="btn btn-primary btn-block btn-tiny"><i class="fas fa-clock"></i> Pending</div>
                        <div class="btn btn-primary btn-block btn-tiny"><i class="fas fa-times-circle"></i> Rejected</div>
                    </div>
                </div>

                <button class="btn btn-secondary btn-block"><i class="fas fa-filter"></i> Apply Filters</button>
            </div>
        </div>

        <!-- Today's Clock-in Entries -->
        <div class="card timesheet-table-container" id="clock-in-entries">
            <div class="table-header">
                <h3>Today's Clock-in Entries</h3>
                <div class="table-actions">
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-sync"></i> Refresh</button>
                </div>
            </div>

            <div class="table-responsive">
                <!-- Debug info to check if today's entries exist -->
                <div style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">
                    <% if (entries && entries.length > 0) { %>
                        Found <%= entries.length %> entries for today.
                    <% } else { %>
                        No entries found for today.
                    <% } %>
                </div>

                <table class="timesheet-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Clock In</th>
                            <th>Clock Out</th>
                            <th>Break Time</th>
                            <th>Unavailable Time</th>
                            <th>Hours</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <%
                        // Debug logging to see what today's entries are available
                        console.log('Today\'s entries in view:', entries);

                        if (entries && entries.length > 0) {
                        %>
                            <% entries.forEach((entry, index) => {
                                // Format times
                                let clockInTime = 'N/A';
                                if (entry.start_time) {
                                    const startTime = new Date(entry.start_time);
                                    clockInTime = startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                let clockOutTime = 'N/A';
                                if (entry.end_time) {
                                    const endTime = new Date(entry.end_time);
                                    clockOutTime = endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                // Format hours
                                let hoursDisplay = 'N/A';
                                if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                    const hours = Math.floor(entry.hours_worked);
                                    const minutes = Math.round((entry.hours_worked % 1) * 60);
                                    hoursDisplay = `${hours}h ${minutes}m`;
                                }
                            %>
                                <tr>
                                    <td><%= index + 1 %></td>
                                    <td><%= clockInTime %></td>
                                    <td><%= clockOutTime %></td>
                                    <td><%= entry.total_break_duration || 0 %> mins</td>
                                    <td><%= entry.total_unavailable_duration || 0 %> mins</td>
                                    <td><%= hoursDisplay %></td>
                                    <td>
                                        <%
                                          const status = (entry.rawEntry && entry.rawEntry.status) ? entry.rawEntry.status : 'Unknown';
                                          const statusClass = status.toLowerCase();
                                        %>
                                        <span class="status-badge status-<%= statusClass %>"><%= status %></span>
                                    </td>
                                </tr>
                            <% }); %>
                        <% } else { %>
                            <tr>
                                <td colspan="7" class="no-entries">No clock-in entries for today</td>
                            </tr>
                        <% } %>
                    </tbody>
                </table>
            </div>
        </div>
        </div>
        <div class="timesheet-recent">
        <!-- Recent Time Entries -->
        <div class="card timesheet-table-container">
            <div class="table-header">
                <h3>Recent Time Entries</h3>
                <div class="table-actions">
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-download"></i> Export</button>
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-print"></i> Print</button>
                </div>
            </div>

            <div class="table-responsive">
                <!-- Debug info to check if entries exist -->
                <div style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">
                    <% if (entries && entries.length > 0) { %> <%# Use entries directly %>
                        Found <%= entries.length %> recent entries. <%# Use entries directly %>
                    <% } else { %>
                        No recent entries found.
                    <% } %>
                </div>

                <table class="timesheet-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Clock In</th>
                            <th>Clock Out</th>
                            <th>Break Time</th>
                            <th>Unavailable Time</th>
                            <th>Total Hours</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <%
                        // Debug logging to see what entries are available
                        console.log('Entries in view:', entries);

                        if (entries && entries.length > 0) {
                        %>
                            <% entries.forEach((entry, index) => { %>
                                <%
                                // Debug logging for each entry
                                console.log(`Rendering entry ${index}:`, entry);
                                %>
                                <tr>
                                    <td><%= entry.date || 'N/A' %></td>
                                    <td><%= entry.login || 'N/A' %></td>
                                    <td><%= entry.logout || 'N/A' %></td>
                                    <td><%= entry.pause || '0 mins' %></td>
                                    <td><%= entry.unavailable || '0 mins' %></td>
                                    <td><%= entry.totalAvailable || 'N/A' %></td>
                                    <td>
                                        <%
                                          // Access status via rawEntry, with safety checks
                                          const status = (entry.rawEntry && entry.rawEntry.status) ? entry.rawEntry.status : 'Unknown';
                                          const statusClass = status.toLowerCase();
                                        %>
                                        <span class="status-badge status-<%= statusClass %>"><%= status %></span>
                                    </td>
                                </tr>
                            <% }); %>
                        <% } else { %>
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 20px; color: #777; font-style: italic;">No recent time entries found.</td>
                            </tr>
                        <% } %>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Statistics Section -->
    <div class="stats-section">
        <h3 class="section-title">Work Statistics <span class="title-highlight"></span></h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
                <div class="stat-content">
                    <h4>Productivity</h4>
                    <div class="stat-value">85%</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 85%"></div>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-history"></i>
                </div>
                <div class="stat-content">
                    <h4>Average Hours</h4>
                    <div class="stat-value">7.5 hrs</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 75%"></div>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-user-clock"></i>
                </div>
                <div class="stat-content">
                    <h4>On Time Rate</h4>
                    <div class="stat-value">92%</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 92%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Custom Animations CSS -->
<style>
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .dashboard-card:hover .card-icon {
        animation: pulse 1.5s ease infinite;
    }

    @keyframes fadeSlideUp {
        0% {
            opacity: 0;
            transform: translateY(20px);
        }
        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animated {
        animation: fadeSlideUp 0.6s ease-out forwards;
    }

    section {
        opacity: 0;
        transform: translateY(40px);
        transition: opacity 0.8s ease, transform 0.8s ease;
    }

    section.visible {
        opacity: 1;
        transform: translateY(0);
    }

    /* Notification styles */
    .notification-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .notification {
        background-color: #333;
        color: white;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-width: 300px;
        max-width: 400px;
        animation: slide-in 0.3s ease-out forwards;
    }

    .notification.success {
        background-color: #4CAF50;
    }

    .notification.error {
        background-color: #F44336;
    }

    .notification.warning {
        background-color: #FF9800;
    }

    .notification-content {
        flex: 1;
    }

    .notification-close {
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        margin-left: 10px;
    }

    .notification.fade-out {
        animation: fade-out 0.3s ease-out forwards;
    }

    @keyframes slide-in {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    @keyframes fade-out {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }

    /* Highlight effect for buttons */
    .btn-highlight {
        animation: pulse 1s infinite;
        box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
    }

    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 165, 0, 1);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Cache DOM elements
    const statusTextElement = document.getElementById('statusText');
    const timesheetClockInTimeElement = document.getElementById('clockInTime'); // Renamed variable
    const totalBreakTimeText = document.getElementById('totalBreakTime');
    const clockInBtn = document.getElementById('clockInBtn');
    const clockOutBtn = document.getElementById('clockOutBtn');
    const startBreakBtn = document.getElementById('startBreakBtn');
    const endBreakBtn = document.getElementById('endBreakBtn');
    const startUnavailableBtn = document.getElementById('startUnavailableBtn');
    const endUnavailableBtn = document.getElementById('endUnavailableBtn');

    // Get elements needed for live updates
    const hoursWorkedElement = document.getElementById('hours-worked');
    const hoursRemainingElement = document.getElementById('hours-remaining');
    const progressBarElement = document.getElementById('work-progress-bar');

    // Get elements from the Timer Display Section
    const timerHoursWorkedElement = document.getElementById('timer-hours-worked');
    const countdownTimerElement = document.getElementById('countdown-timer');
    const timerBarElement = document.querySelector('.progress-bar.timer-bar');

    // Helper to format hours into Xh Ym
    function formatHoursMinutes(decimalHours) {
        if (typeof decimalHours !== 'number' || isNaN(decimalHours)) {
            return 'N/A';
        }
        const totalMinutes = Math.max(0, Math.round(decimalHours * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        return `${hours}h ${minutes}m`;
    }

    // Function to update the display live (will be called by setInterval)
    function updateLiveDisplay() {
        // Check if the main.js timer is running
        if (window.timerRunning && !window.timesheetTimerRunning) {
            console.log('Main.js timer is running. Stopping timesheet timer.');
            if (window.liveTimerIntervalId) {
                clearInterval(window.liveTimerIntervalId);
                window.liveTimerIntervalId = null;
            }
            return;
        }

        if (!window.sessionStartTime || window.baseHoursWorked === null) {
            // Not actively working or base data not set
            // console.log('Live update skipped: No session start time or base hours.');
            return;
        }

        const now = new Date();
        const elapsedMilliseconds = now - window.sessionStartTime;
        const elapsedSeconds = elapsedMilliseconds / 1000;
        const elapsedHours = elapsedSeconds / 3600;

        // Get the active entry from the status data
        const activeEntry = window.activeEntry || {};

        // IMPORTANT: We need to be careful about how we calculate the total hours worked
        // to avoid double-counting. There are two scenarios:

        // 1. If the user has just clocked in, the active entry's hours_worked field already
        //    includes all accumulated hours from previous clock-ins, and we need to add the
        //    elapsed hours from the current session.
        // 2. If the user has clocked out, we should use the hours_worked field directly
        //    without adding any elapsed hours.

        let currentTotalHours = 0;
        let currentSessionHours = 0;

        // Check if the user is actively clocked in
        if (activeEntry.status === 'active' && !activeEntry.end_time) {
            // User is actively clocked in - calculate elapsed hours for current session
            currentSessionHours = elapsedHours;

            // Get the accumulated hours from the active entry
            const accumulatedHours = activeEntry.hours_worked || 0;

            // Calculate the total hours worked for the day
            currentTotalHours = accumulatedHours + currentSessionHours;

            console.log('User is actively clocked in');
            console.log('Accumulated hours from active entry:', accumulatedHours);
            console.log('Current session hours:', currentSessionHours);
            console.log('Total hours worked today (all clock-ins):', currentTotalHours);

            // Log more details about the accumulated hours
            console.log('Accumulated hours breakdown:');
            console.log('- Hours from previous clock-ins (from active entry):', accumulatedHours);
            console.log('- Hours from current session:', currentSessionHours);
            console.log('- Total accumulated hours:', currentTotalHours);
        } else {
            // User is not actively clocked in - use the hours_worked field directly
            currentTotalHours = activeEntry.hours_worked || 0;

            console.log('User is not actively clocked in');
            console.log('Total hours worked today (from active entry):', currentTotalHours);

            // IMPORTANT: When the user is not actively clocked in, we should not add any elapsed hours
            // to the total hours worked. This prevents the timer from continuing to count up after
            // the user has clocked out.
            window.timerRunning = false;
            if (window.liveTimerIntervalId) {
                clearInterval(window.liveTimerIntervalId);
                window.liveTimerIntervalId = null;
                console.log('Stopped live timer because user is not actively clocked in.');
            }
        }

        // Store the total hours worked for the day in a global variable
        // This will be used when the page is refreshed or when the user navigates away and back
        window.totalHoursWorkedToday = currentTotalHours;

        // Calculate the remaining hours in the 8-hour workday
        const currentRemainingHours = Math.max(0, 8 - currentTotalHours); // Assuming 8-hour day

        // Store the remaining hours in a global variable for consistency
        window.remainingHoursToday = currentRemainingHours;

        // Also update localStorage to persist the values across page refreshes
        const today = new Date().toISOString().split('T')[0];
        localStorage.setItem('lastWorkDate', today);
        localStorage.setItem('totalHoursWorkedToday', currentTotalHours.toString());
        localStorage.setItem('remainingHoursToday', currentRemainingHours.toString());
        // console.log('Updated localStorage with current values');

        // Calculate the percentage for the progress bar
        const percentage = Math.min(100, Math.max(0, (currentTotalHours / 8) * 100));

        // Format the hours for display
        const formattedHoursWorked = formatHoursMinutes(currentTotalHours);
        const formattedRemainingHours = formatHoursMinutes(currentRemainingHours);

        console.log('Current session hours:', currentSessionHours);
        console.log('Total hours worked today:', currentTotalHours);
        console.log('Remaining hours:', currentRemainingHours);

        // Update Hours Today card
        if (hoursWorkedElement) {
            hoursWorkedElement.textContent = formattedHoursWorked;
            hoursWorkedElement.setAttribute('data-hours-worked', currentTotalHours.toString());
        }
        if (hoursRemainingElement) {
            hoursRemainingElement.textContent = formattedRemainingHours;
            hoursRemainingElement.setAttribute('data-remaining-hours', currentRemainingHours.toString());
        }
        if (progressBarElement) {
            progressBarElement.style.width = `${percentage}%`;
        }

        // Update Timer Display Section
        if (timerHoursWorkedElement) {
            timerHoursWorkedElement.textContent = formattedHoursWorked;
        }
        if (countdownTimerElement) {
            countdownTimerElement.textContent = formattedRemainingHours;
        }
        if (timerBarElement) {
            timerBarElement.style.width = `${percentage}%`;
            timerBarElement.setAttribute('aria-valuenow', currentTotalHours.toString());
        }
    }

    // Function to display notifications
    function showNotification(message, type = 'info') {
        // Create notification container if it doesn't exist
        let notificationContainer = document.querySelector('.notification-container');

        if (!notificationContainer) {
            notificationContainer = document.createElement('div');
            notificationContainer.className = 'notification-container';
            document.body.appendChild(notificationContainer);
        }

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span>${message}</span>
            </div>
            <button class="notification-close">&times;</button>
        `;

        // Add notification to container
        notificationContainer.appendChild(notification);

        // Add close button functionality
        const closeButton = notification.querySelector('.notification-close');
        closeButton.addEventListener('click', function() {
            notification.classList.add('fade-out');
            setTimeout(() => {
                notification.remove();
            }, 300);
        });

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.add('fade-out');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 5000);
    }

    // Function to update the UI based on current timesheet status
    function updateUI(statusData) {
        const activeEntry = statusData.activeEntry;
        console.log('Updating UI with data:', statusData);

        // Store the active entry in a global variable for use in updateLiveDisplay
        window.activeEntry = activeEntry;
        console.log('Stored active entry in global variable:', window.activeEntry);

        // Clear previous timer interval if it exists
        if (window.liveTimerIntervalId) {
            clearInterval(window.liveTimerIntervalId);
            window.liveTimerIntervalId = null;
            window.timesheetTimerRunning = false;
            console.log('Cleared existing live timer.');
        }
        // Reset base values used by the timer
        window.baseHoursWorked = null;
        window.sessionStartTime = null;

        // Check if we have stored values in localStorage from the same day
        const today = new Date().toISOString().split('T')[0];
        const lastWorkDate = localStorage.getItem('lastWorkDate');
        let storedHoursWorked = 0;
        let storedRemainingHours = 0;

        // If we have stored values from the same day, use them
        if (lastWorkDate === today) {
            storedHoursWorked = parseFloat(localStorage.getItem('totalHoursWorkedToday') || '0');
            storedRemainingHours = parseFloat(localStorage.getItem('remainingHoursToday') || '8');
            console.log('Found stored values from today:', lastWorkDate);
            console.log('Stored hours worked:', storedHoursWorked);
            console.log('Stored remaining hours:', storedRemainingHours);
        } else {
            console.log('No stored values from today or different day. Last work date:', lastWorkDate);
        }

        // Get the hours worked from the status data, window variable, or localStorage
        const initialHoursWorked = statusData.hoursWorkedRaw !== undefined ? statusData.hoursWorkedRaw :
                                  (window.totalHoursWorkedToday !== undefined ? window.totalHoursWorkedToday :
                                   (lastWorkDate === today ? storedHoursWorked : 0));

        // Calculate remaining hours based on total hours worked
        // Use the value from the status data, window variable, or localStorage
        const initialRemainingHours = statusData.remainingHoursRaw !== undefined ? statusData.remainingHoursRaw :
                                     (window.remainingHoursToday !== undefined ? window.remainingHoursToday :
                                      (lastWorkDate === today ? storedRemainingHours : Math.max(0, 8 - initialHoursWorked)));

        // Store these values in global variables for consistency across all timers
        window.totalHoursWorkedToday = initialHoursWorked;
        window.remainingHoursToday = initialRemainingHours;

        // Also update localStorage
        localStorage.setItem('lastWorkDate', today);
        localStorage.setItem('totalHoursWorkedToday', initialHoursWorked.toString());
        localStorage.setItem('remainingHoursToday', initialRemainingHours.toString());

        console.log('Initial hours worked set to:', initialHoursWorked);
        console.log('Initial remaining hours set to:', initialRemainingHours);

        // --- Update display elements initially based on statusData ---
        // Set static display elements based on fetched data. Live timer will overwrite if active.
        const initialPercentage = Math.min(100, Math.max(0, (initialHoursWorked / 8) * 100));
        const formattedHoursWorked = formatHoursMinutes(initialHoursWorked);
        const formattedRemainingHours = formatHoursMinutes(initialRemainingHours);

        // Update Hours Today card
        if (hoursWorkedElement) {
             hoursWorkedElement.textContent = formattedHoursWorked;
             hoursWorkedElement.setAttribute('data-hours-worked', initialHoursWorked.toString());
        }
        if (hoursRemainingElement) {
            hoursRemainingElement.textContent = formattedRemainingHours;
            hoursRemainingElement.setAttribute('data-remaining-hours', initialRemainingHours.toString());
        }
        if (progressBarElement) {
            progressBarElement.style.width = `${initialPercentage}%`;
        }

        // Update Timer Display Section
        if (timerHoursWorkedElement) {
            timerHoursWorkedElement.textContent = formattedHoursWorked;
        }
        if (countdownTimerElement) {
            countdownTimerElement.textContent = formattedRemainingHours;
        }
        if (timerBarElement) {
            timerBarElement.style.width = `${initialPercentage}%`;
            timerBarElement.setAttribute('aria-valuenow', initialHoursWorked.toString());
        }

        // Store the initial hours worked in a global variable
        window.totalHoursWorkedToday = initialHoursWorked;

        // Reset all buttons to default state (mostly disabled)
        clockInBtn.disabled = true;
        clockOutBtn.disabled = true;
        startBreakBtn.disabled = true;
        endBreakBtn.disabled = true;
        startUnavailableBtn.disabled = true;
        endUnavailableBtn.disabled = true;
        statusTextElement.textContent = 'Not Clocked In';
        timesheetClockInTimeElement.textContent = '--:--'; // Renamed variable
        totalBreakTimeText.textContent = '0 mins';

        if (activeEntry) {
            // User is clocked in
            clockOutBtn.disabled = false; // Base state when clocked in
            statusTextElement.textContent = `Status: ${activeEntry.status || 'Unknown'}`; // Default
            if (activeEntry.start_time) {
                timesheetClockInTimeElement.textContent = new Date(activeEntry.start_time).toLocaleTimeString(); // Renamed variable
            }
             if (activeEntry.total_break_duration !== undefined) {
                 totalBreakTimeText.textContent = `${Math.round(activeEntry.total_break_duration)} mins`;
             }

            // Determine specific state based on status
            if (activeEntry.status === 'active') {
                startBreakBtn.disabled = false;
                startUnavailableBtn.disabled = false;
                clockOutBtn.disabled = false; // Ensure clock out is enabled
                statusTextElement.textContent = 'Active - Currently Working';

                // Check if we have stored values in localStorage from the same day
                const today = new Date().toISOString().split('T')[0];
                const lastWorkDate = localStorage.getItem('lastWorkDate');
                let storedHoursWorked = 0;

                // If we have stored values from the same day, use them
                if (lastWorkDate === today) {
                    storedHoursWorked = parseFloat(localStorage.getItem('totalHoursWorkedToday') || '0');
                    console.log('Found stored hours worked from today:', storedHoursWorked);
                }

                // IMPORTANT: We need to be careful about how we calculate the total hours worked
                // to avoid double-counting. When a user is actively clocked in, we should:
                // 1. Set baseHoursWorked to 0
                // 2. Use the active entry's hours_worked field as the accumulated hours
                // 3. Add the elapsed hours from the current session to the accumulated hours

                // ALWAYS set baseHoursWorked to 0 when a user is actively clocked in
                // This is because the active entry's hours_worked field already includes all accumulated hours
                window.baseHoursWorked = 0;

                // Get the accumulated hours from the active entry
                const accumulatedHours = activeEntry.hours_worked || 0;

                // Calculate the remaining hours based on the accumulated hours
                window.remainingHoursToday = Math.max(0, 8 - accumulatedHours);

                console.log('Set baseHoursWorked to 0 to avoid double-counting accumulated hours');
                console.log('Accumulated hours from active entry:', accumulatedHours);
                console.log('Calculated remaining hours:', window.remainingHoursToday);

                // Log more details about the accumulated hours
                console.log('Accumulated hours breakdown at timer start:');
                console.log('- Hours from previous clock-ins (from active entry):', accumulatedHours);
                console.log('- Hours from current session: 0 (just starting)');
                console.log('- Total accumulated hours (before current session):', accumulatedHours);

                // For the session start time, we need to calculate it based on the current time and the elapsed hours
                // in the current session to ensure the timer continues correctly
                const now = new Date();

                // The session start time is the time when the user clocked in most recently
                const sessionStartTime = activeEntry.start_time ? new Date(activeEntry.start_time) : null;

                // Store the session start time for the timer
                window.sessionStartTime = sessionStartTime;

                console.log('Session start time set to:', window.sessionStartTime);

                // Update localStorage with the current values
                localStorage.setItem('lastWorkDate', today);
                localStorage.setItem('totalHoursWorkedToday', window.baseHoursWorked.toString());
                localStorage.setItem('remainingHoursToday', Math.max(0, 8 - window.baseHoursWorked).toString());

                console.log('Base hours worked set:', window.baseHoursWorked);
                console.log('Session start time set:', window.sessionStartTime);
                console.log('Current session hours: 0 (just starting)');

                // Start the live timer ONLY if sessionStartTime is valid and no timer is already running
                // Check both our own timer and the main.js timer
                if (window.sessionStartTime && !window.liveTimerIntervalId && !window.timerRunning) {
                    console.log('Starting live timer from timesheet.ejs');
                    // Set a global flag to indicate that our timer is running
                    window.timesheetTimerRunning = true;
                    updateLiveDisplay(); // Initial update immediately using calculated live value
                    window.liveTimerIntervalId = setInterval(updateLiveDisplay, 1000);
                } else if (window.timerRunning) {
                    console.log('Not starting timesheet timer because main.js timer is already running');
                }
            } else {
                // Handle 'on_break', 'unavailable', or other clocked-in states
                // Timer should be stopped (already handled above by clearing interval)
                // Static display values (hours worked/remaining/progress) were already set
                // at the beginning of updateUI based on fetched data.
                if (activeEntry.status === 'on_break') {
                    endBreakBtn.disabled = false;
                    startBreakBtn.disabled = true;
                    startUnavailableBtn.disabled = true;
                    clockOutBtn.disabled = true;
                    statusTextElement.textContent = 'On Break';
                } else if (activeEntry.status === 'unavailable') {
                    endUnavailableBtn.disabled = false;
                    startBreakBtn.disabled = true;
                    startUnavailableBtn.disabled = true;
                    clockOutBtn.disabled = true;
                    statusTextElement.textContent = 'Unavailable';
                } else {
                     // Handle any other potential statuses or fallback
                     console.warn('Unknown activeEntry status:', activeEntry.status);
                     statusTextElement.textContent = `Status: ${activeEntry.status || 'Unknown'}`;
                     // Keep clock out enabled as a default if clocked in but status unknown?
                     clockOutBtn.disabled = false;
                }
                // Ensure clock-in is always disabled when clocked in
                clockInBtn.disabled = true;
            }
        } else {
            // User is not clocked in
            clockInBtn.disabled = false; // Enable clock-in
            statusTextElement.textContent = 'Not Clocked In';
             // Ensure progress bar resets if not clocked in
             if (progressBarElement) {
                 progressBarElement.style.width = '0%';
             }
             // Reset display hours explicitly to 0 / 8
             if (hoursWorkedElement) hoursWorkedElement.textContent = formatHoursMinutes(0);
             if (hoursRemainingElement) hoursRemainingElement.textContent = formatHoursMinutes(8);
        }
    }

    // Function to fetch status and update UI
    async function fetchAndUpdateStatus() {
        const token = localStorage.getItem('token'); // Get JWT from local storage
        console.log('Token available:', token ? 'Yes' : 'No');
        if (!token) {
            console.error('No JWT found. User might not be logged in.');
            statusTextElement.textContent = 'Error: Not authenticated';
            // Optionally redirect to login or disable all buttons
            return;
        }
        console.log('Using token for status fetch:', token.substring(0, 20) + '...');

        try {
            const response = await fetch('/api/status', { // Corrected endpoint
                 headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}` // Add JWT to header
                 }
            });
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                    // Handle unauthorized/forbidden (e.g., redirect to login)
                    console.error('Authentication error fetching status.');
                    statusTextElement.textContent = 'Authentication Error';
                    // Consider redirecting: window.location.href = '/login';
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return; // Stop further processing on error
            }
            const statusData = await response.json();

            // Ensure we have the correct hours worked and remaining hours
            if (statusData.hoursWorked !== undefined) {
                // Store the total hours worked for the day in a global variable
                window.totalHoursWorkedToday = statusData.hoursWorked;
                console.log('Stored total hours worked today from server:', window.totalHoursWorkedToday);

                // Calculate remaining hours based on total hours worked
                // This is crucial - we need to subtract the accumulated hours from the standard 8-hour day
                statusData.remainingHours = Math.max(0, 8 - statusData.hoursWorked);
                statusData.remainingHoursRaw = statusData.remainingHours;

                // Store the remaining hours in a global variable for the timer
                window.remainingHoursToday = statusData.remainingHours;
                console.log('Calculated and stored remaining hours:', statusData.remainingHours);

                // Store the current date in localStorage to track if it's the same day
                const today = new Date().toISOString().split('T')[0];
                localStorage.setItem('lastWorkDate', today);
                localStorage.setItem('totalHoursWorkedToday', statusData.hoursWorked.toString());
                localStorage.setItem('remainingHoursToday', statusData.remainingHours.toString());
                console.log('Stored work data in localStorage for date:', today);

                // Log the values for debugging
                console.log('Current timer values:');
                console.log('- Total hours worked today:', window.totalHoursWorkedToday);
                console.log('- Remaining hours today:', window.remainingHoursToday);
            }

            // Store the active entry in a global variable for use in other functions
            window.activeEntry = statusData.activeEntry;
            console.log('Stored active entry in global variable:', window.activeEntry);

            updateUI(statusData);

            // Start the timer if the user is actively working and the timer is not already running
            if (statusData.activeEntry && statusData.activeEntry.status === 'active' &&
                typeof window.updateCountdown === 'function' && !window.timerRunning) {
                console.log('Starting timer from fetchAndUpdateStatus function');
                window.updateCountdown();
            }
        } catch (error) {
            console.error('Error fetching timesheet status:', error);
            statusTextElement.textContent = 'Error loading status';
            // Disable all buttons on error?
            clockInBtn.disabled = true;
            clockOutBtn.disabled = true;
            startBreakBtn.disabled = true;
            endBreakBtn.disabled = true;
            startUnavailableBtn.disabled = true;
            endUnavailableBtn.disabled = true;
        }
    }

    // Helper function to send time tracking requests
    async function sendTimeTrackingRequest(url, method, data = {}) {
        console.log(`Sending ${method} request to ${url} with data:`, data);
        const token = localStorage.getItem('token');
        if (!token) {
            throw new Error('No authentication token found');
        }

        const response = await fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(data)
        });

        // Special handling for 400 status with 'Already actively clocked in' message
        // This is used for the force clock-in feature
        if (response.status === 400) {
            const result = await response.json();
            if (result.message && result.message.includes('Already actively clocked in') && result.canForceClockIn) {
                console.log('Detected force clock-in scenario:', result);
                return result; // Return the result with canForceClockIn flag
            }
            // For other 400 errors, throw normally
            throw new Error(result.message || 'Request failed');
        }

        // For non-200 responses that aren't the special case above
        if (!response.ok) {
            const errorText = await response.text();
            let errorMessage;
            try {
                const errorJson = JSON.parse(errorText);
                errorMessage = errorJson.message || errorJson.error || `Request failed with status ${response.status}`;
            } catch (e) {
                errorMessage = `Request failed with status ${response.status}: ${errorText}`;
            }
            throw new Error(errorMessage);
        }

        // For successful responses
        return await response.json();
    }

    // Generic function to handle API calls for other timesheet actions
    async function handleTimesheetAction(action, successMessage, errorMessagePrefix) {
        console.log(`${action} button clicked`);
        const token = localStorage.getItem('token'); // Get JWT from local storage
        if (!token) {
            console.error('No JWT found for action.');
            showNotification('Authentication error. Please log in again.', 'error');
            return;
        }

        console.log(`Sending ${action} request to /api/${action}`);
        console.log('Using token:', token ? (token.substring(0, 20) + '...') : 'No token');

        try {
            const response = await fetch(`/api/${action}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}` // Add JWT to header
                },
            });

            console.log(`${action} response status:`, response.status);

            // Handle potential JSON parsing errors if response is not JSON (e.g., 204 No Content)
            let result = {};
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.indexOf("application/json") !== -1) {
                try {
                    result = await response.json();
                    console.log(`${action} response data:`, result);
                } catch (jsonError) {
                    console.error(`Error parsing JSON response for ${action}:`, jsonError);
                    result = { error: 'Invalid response format' };
                }
            } else if (!response.ok) {
                 // If not JSON and not OK, create a basic error message
                 result = { error: `Request failed with status ${response.status}` };
                 console.error(`Non-JSON error response for ${action}:`, result.error);
            }

            if (response.ok) {
                console.log(`${action} successful:`, result);
                showNotification(successMessage, 'success');
                // Wait a moment before refreshing the UI to ensure the server has processed the change
                setTimeout(() => {
                    fetchAndUpdateStatus(); // Refresh UI
                }, 500);
            } else {
                const errorMessage = result.message || result.error || 'Unknown error';
                console.error(`${action} failed:`, errorMessage);
                showNotification(`${errorMessagePrefix}: ${errorMessage}`, 'error');
            }
        } catch (error) {
            console.error(`Error sending ${action} request:`, error);
            showNotification(`An error occurred while trying to ${action.replace('-', ' ')}.`, 'error');
        }
    }

    // Check for inconsistent timesheet state on page load
    async function initialStateCheck() {
        try {
            // Directly fetch and update status - this handles inconsistencies
            // by showing the actual server state.
            await fetchAndUpdateStatus();
            console.log('Initial status fetched and UI updated.');
        } catch (error) {
            console.error('Error during initial state check:', error);
            // Attempt to fetch status even if the initial check had an error
            // (though with the simplification, this catch block might be less necessary)
            fetchAndUpdateStatus();
        }
    }

    // Initial status fetch on page load with state consistency check
    initialStateCheck();

    // Set up periodic refresh every 3 minutes to avoid conflicts with the timer
    const statusRefreshInterval = setInterval(() => {
        console.log('Performing periodic status refresh');
        // Only refresh if no timer is running
        if (!window.timerRunning) {
            console.log('No timer running, safe to refresh status');
            // Also check for inconsistent state during periodic refresh
            initialStateCheck();
        } else {
            console.log('Timer is running, skipping status refresh to avoid conflicts');
        }
    }, 180000); // 3 minutes

    // Clean up interval when page is unloaded
    window.addEventListener('beforeunload', () => {
        clearInterval(statusRefreshInterval);
    });

    // --- Event Listeners ---

    // Clock In
    if (clockInBtn) {
        clockInBtn.addEventListener('click', async () => {
            console.log('Clock In button clicked');
            try {
                // Default is not to force clock in
                let forceClockIn = false;
                let result = null;

                // Initial attempt to clock in
                console.log('Attempting initial clock-in via sendTimeTrackingRequest');
                result = await sendTimeTrackingRequest('/api/clock-in', 'POST', { force: forceClockIn });
                console.log('Initial clock-in attempt result:', result);

                // Check if the response indicates an existing active entry that can be forced
                if (result && result.message && result.message.includes('Already actively clocked in') && result.canForceClockIn && result.activeEntry) {
                    console.log('Detected stuck active entry:', result.activeEntry);

                    // Calculate how long the entry has been active
                    const startTime = new Date(result.activeEntry.start_time);
                    const now = new Date();
                    const hoursActive = ((now - startTime) / (1000 * 60 * 60)).toFixed(1);

                    // Ask the user if they want to force clock in
                    const confirmForce = confirm(
                        `You appear to have an active timesheet entry from ${startTime.toLocaleString()} (${hoursActive} hours ago) ` +
                        `that was never properly closed.\n\n` +
                        `Would you like to automatically close this entry and clock in now?\n\n` +
                        `Note: This will calculate the hours worked for the previous entry and submit it.`
                    );

                    if (confirmForce) {
                        console.log('User confirmed force clock in. Sending request with force=true.');
                        // Send the request again with force=true using the helper
                        result = await sendTimeTrackingRequest('/api/clock-in', 'POST', { force: true });
                        console.log('Force clock-in attempt result:', result);
                    } else {
                        console.log('User cancelled force clock in');
                        showNotification('Clock in cancelled. Please try again or contact support if the issue persists.', 'warning');
                        return; // Exit if user cancels
                    }
                }

                // Process the final result (either from initial attempt or forced attempt)
                // sendTimeTrackingRequest throws an error for non-OK responses unless handled specially (like the 400 force case)
                // So, if we reach here without an error, it means the operation was successful OR it was the handled 400 force case that the user didn't confirm.
                // We need to ensure 'result' actually indicates success if it wasn't the cancelled force scenario.

                if (result && result.success) { // Check for a success flag or appropriate data from your API response
                    console.log('Clock in successful:', result);
                    const successMessage = result.message || 'Clocked in successfully!';
                    showNotification(successMessage, 'success');

                    // --- UI Update Logic (Copied from original, check if still relevant) ---
                    if (result.allEntries && result.allEntries.length > 0) {
                        // Calculate total hours worked from all entries
                        let totalHoursWorked = 0;
                        result.allEntries.forEach(entry => {
                            if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                totalHoursWorked += parseFloat(entry.hours_worked);
                            }
                        });

                        // Store the total hours worked in a global variable
                        window.totalHoursWorkedToday = totalHoursWorked;
                        console.log('Stored total hours worked today:', window.totalHoursWorkedToday);

                        // Calculate remaining hours based on total hours worked
                        const remainingHours = Math.max(0, 8 - totalHoursWorked);
                        window.remainingHoursToday = remainingHours;
                        console.log('Calculated remaining hours today:', window.remainingHoursToday);

                        // Store the active entry in a global variable for use in updateLiveDisplay
                        window.activeEntry = result.entry;
                        console.log('Stored active entry in global variable:', window.activeEntry);

                        // IMPORTANT: Set baseHoursWorked to 0 because the accumulated hours are already
                        // stored in the active entry's hours_worked field. If we use the accumulated hours
                        // as the base, we'll be double-counting them.
                        window.baseHoursWorked = 0;
                        console.log('Set baseHoursWorked to 0 to avoid double-counting accumulated hours');

                        // Log more details about the accumulated hours
                        console.log('Accumulated hours breakdown after clock-in:');
                        console.log('- Hours from previous clock-ins (from active entry):', result.entry.hours_worked || 0);
                        console.log('- Hours from current session: 0 (just starting)');
                        console.log('- Total accumulated hours:', result.entry.hours_worked || 0);

                        const hoursWorkedElement = document.getElementById('hours-worked');
                        const hoursWorkedData = document.getElementById('hours-worked-data');
                        const countdownElement = document.getElementById('countdown-timer');
                        const remainingHoursData = document.getElementById('remaining-hours-data');

                        // Update data attributes with the calculated values
                        if (hoursWorkedElement) {
                            hoursWorkedElement.setAttribute('data-total-hours-worked', totalHoursWorked.toString());

                            // Format hours worked for display
                            const hours = Math.floor(totalHoursWorked);
                            const minutes = Math.round((totalHoursWorked % 1) * 60);
                            const formattedHoursWorked = `${hours}h ${minutes}m`;
                            hoursWorkedElement.textContent = formattedHoursWorked;
                            console.log(`Updated hours-worked element to: ${formattedHoursWorked}`);
                        }

                        if (hoursWorkedData) {
                            hoursWorkedData.setAttribute('data-total-hours-worked', totalHoursWorked.toString());
                        }

                        // Update remaining hours display
                        if (countdownElement) {
                            countdownElement.setAttribute('data-server-remaining-hours', remainingHours.toString());

                            // Format remaining hours for display
                            const hours = Math.floor(remainingHours);
                            const minutes = Math.round((remainingHours % 1) * 60);
                            const formattedRemainingHours = `${hours}h ${minutes}m`;
                            countdownElement.textContent = formattedRemainingHours;
                            console.log(`Updated countdown-timer element to: ${formattedRemainingHours}`);
                        }

                        if (remainingHoursData) {
                            remainingHoursData.setAttribute('data-server-remaining-hours', remainingHours.toString());
                        }

                        // Also update the hours-remaining element if it exists
                        const hoursRemainingElement = document.getElementById('hours-remaining');
                        if (hoursRemainingElement) {
                            const hours = Math.floor(remainingHours);
                            const minutes = Math.round((remainingHours % 1) * 60);
                            const formattedRemainingHours = `${hours}h ${minutes}m`;
                            hoursRemainingElement.textContent = formattedRemainingHours;
                            console.log(`Updated hours-remaining element to: ${formattedRemainingHours}`);
                        }

                        // Refresh the today's entries table
                        const todayEntriesTable = document.querySelector('.timesheet-table tbody');
                        if (todayEntriesTable) {
                            todayEntriesTable.innerHTML = ''; // Clear existing
                            result.allEntries.forEach((entry, index) => {
                                let clockInTime = entry.start_time ? new Date(entry.start_time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'N/A';
                                let clockOutTime = entry.end_time ? new Date(entry.end_time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'N/A';
                                let hoursDisplay = 'N/A';
                                if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                    const hours = Math.floor(entry.hours_worked);
                                    const minutes = Math.round((entry.hours_worked % 1) * 60);
                                    hoursDisplay = `${hours}h ${minutes}m`;
                                }
                                const status = (entry.status || 'Unknown'); // Simplified status fetch
                                const statusClass = status.toLowerCase();
                                const newRow = document.createElement('tr');
                                newRow.innerHTML = `
                                    <td>${index + 1}</td>
                                    <td>${clockInTime}</td>
                                    <td>${clockOutTime}</td>
                                    <td>${entry.total_break_duration || 0} mins</td>
                                    <td>${entry.total_unavailable_duration || 0} mins</td>
                                    <td>${hoursDisplay}</td>
                                    <td><span class="status-badge status-${statusClass}">${status}</span></td>
                                `;
                                todayEntriesTable.appendChild(newRow);
                            });
                        }
                    }
                    // --- End of UI Update Logic ---

                    // Call status update AFTER processing success
                     fetchAndUpdateStatus(); // Refresh UI state based on latest data

                } else if (result && result.message && result.message.includes('Already actively clocked in') && result.canForceClockIn) {
                    // This case handles when the user cancelled the force confirmation
                    console.log('Clock-in attempt resulted in handled 400, but user cancelled force.');
                     // No automatic UI refresh needed here as nothing changed server-side yet
                } else {
                     // If result is null, undefined, or doesn't indicate success, and wasn't the cancelled force scenario
                    console.error('Clock in final result did not indicate success or was unexpected:', result);
                    showNotification('Clock in failed. Unexpected response.', 'error');
                }

            } catch (error) {
                // This catch block now catches errors thrown by sendTimeTrackingRequest for *unhandled* non-OK statuses
                console.error('Error during clock in process:', error);
                showNotification(`Clock in failed: ${error.message}`, 'error');
            }
        });    }

    // Clock Out with debounce to prevent multiple clicks
    if (clockOutBtn) {
        // Add a property to track if a request is in progress
        clockOutBtn.isProcessing = false;

        clockOutBtn.addEventListener('click', async () => {
            console.log('Clock Out button clicked');

            // Prevent multiple clicks
            if (clockOutBtn.isProcessing) {
                console.log('Clock out request already in progress, ignoring click');
                return;
            }

            // Disable the button immediately
            clockOutBtn.isProcessing = true;
            clockOutBtn.disabled = true;

            try {
                // First check if we're clocked in
                const currentStatus = statusTextElement.textContent.toLowerCase();
                if (currentStatus.includes('not clocked in')) {
                    console.log('Cannot clock out when not clocked in');
                    showNotification('You are not currently clocked in.', 'warning');
                    // Highlight the clock in button
                    if (clockInBtn) {
                        clockInBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            clockInBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                // Check if we're on break or unavailable
                if (currentStatus.includes('on break')) {
                    console.log('Cannot clock out while on break');
                    showNotification('Please end your break before clocking out.', 'warning');
                    // Highlight the end break button
                    if (endBreakBtn) {
                        endBreakBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            endBreakBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                if (currentStatus.includes('unavailable')) {
                    console.log('Cannot clock out while unavailable');
                    showNotification('Please end your unavailable period before clocking out.', 'warning');
                    // Highlight the end unavailable button
                    if (endUnavailableBtn) {
                        endUnavailableBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            endUnavailableBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                const token = localStorage.getItem('token');
                console.log('Using token for clock-out:', token ? (token.substring(0, 20) + '...') : 'No token');

                if (!token) {
                    console.error('No JWT token found for clock-out');
                    showNotification('Authentication error. Please log in again.', 'error');
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                // Ask for confirmation before clocking out
                if (!confirm('Are you sure you want to clock out?')) {
                    console.log('Clock out cancelled by user');
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                console.log('Sending clock-out request to /api/clock-out');
                try {
                    // Use the sendTimeTrackingRequest function instead of fetch directly
                    const result = await sendTimeTrackingRequest('/api/clock-out', 'POST');
                    console.log('Clock-out response data:', result);

                    // If we get here, the request was successful
                    console.log('Clock out successful:', result);
                    showNotification('Clocked out successfully!', 'success');

                    // Update the active entry with the result
                    window.activeEntry = result.entry;
                    console.log('Updated active entry with clock-out result:', window.activeEntry);

                    // IMPORTANT: Since the user has clocked out, we need to update the UI immediately
                    // with the correct hours worked value from the server response
                    if (result.entry && result.entry.hours_worked !== undefined) {
                        const totalHoursWorked = result.entry.hours_worked;
                        console.log('Total hours worked from server response:', totalHoursWorked);

                        // Format the hours for display
                        const formattedHoursWorked = formatHoursMinutes(totalHoursWorked);
                        const remainingHours = Math.max(0, 8 - totalHoursWorked);
                        const formattedRemainingHours = formatHoursMinutes(remainingHours);
                        const percentage = Math.min(100, Math.max(0, (totalHoursWorked / 8) * 100));

                        // Update the hours worked display
                        const hoursWorkedElement = document.getElementById('hours-worked');
                        if (hoursWorkedElement) {
                            hoursWorkedElement.textContent = formattedHoursWorked;
                            console.log('Updated hours-worked element to:', formattedHoursWorked);
                        }

                        // Update the remaining hours display
                        const hoursRemainingElement = document.getElementById('hours-remaining');
                        if (hoursRemainingElement) {
                            hoursRemainingElement.textContent = formattedRemainingHours;
                            console.log('Updated hours-remaining element to:', formattedRemainingHours);
                        }

                        // Update the timer display
                        const timerHoursWorkedElement = document.getElementById('timer-hours-worked');
                        if (timerHoursWorkedElement) {
                            timerHoursWorkedElement.textContent = formattedHoursWorked;
                            console.log('Updated timer-hours-worked element to:', formattedHoursWorked);
                        }

                        // Update the countdown timer
                        const countdownTimerElement = document.getElementById('countdown-timer');
                        if (countdownTimerElement) {
                            countdownTimerElement.textContent = formattedRemainingHours;
                            console.log('Updated countdown-timer element to:', formattedRemainingHours);
                        }

                        // Update the progress bars
                        const progressBarElement = document.getElementById('work-progress-bar');
                        if (progressBarElement) {
                            progressBarElement.style.width = `${percentage}%`;
                            console.log('Updated work-progress-bar to:', percentage + '%');
                        }

                        const timerBarElement = document.querySelector('.progress-bar.timer-bar');
                        if (timerBarElement) {
                            timerBarElement.style.width = `${percentage}%`;
                            timerBarElement.setAttribute('aria-valuenow', totalHoursWorked.toString());
                            console.log('Updated timer-bar to:', percentage + '%');
                        }

                        // Store the total hours worked in global variables
                        window.totalHoursWorkedToday = totalHoursWorked;
                        window.remainingHoursToday = remainingHours;

                        // Update localStorage
                        const today = new Date().toISOString().split('T')[0];
                        localStorage.setItem('lastWorkDate', today);
                        localStorage.setItem('totalHoursWorkedToday', totalHoursWorked.toString());
                        localStorage.setItem('remainingHoursToday', remainingHours.toString());

                        // Stop any running timers
                        window.timerRunning = false;
                        if (window.liveTimerIntervalId) {
                            clearInterval(window.liveTimerIntervalId);
                            window.liveTimerIntervalId = null;
                            console.log('Stopped live timer after clock-out.');
                        }
                    } else {
                        console.warn('No hours_worked field found in the response. Using default values.');
                        // Use default values if hours_worked is not available
                        fetchAndUpdateStatus(); // Refresh UI to get the latest data
                    }

                    // Wait a moment before refreshing the UI to ensure the server has processed the change
                    setTimeout(() => {
                        // Refresh UI without referencing any variables from the outer scope
                        fetchAndUpdateStatus();
                    }, 500);
                } catch (error) {
                    console.error('Clock out failed:', error.message);

                    // Handle specific error messages
                    if (error.message.includes('Not clocked in')) {
                        showNotification('You are not currently clocked in.', 'warning');
                    } else {
                        showNotification(`Clock out failed: ${error.message}`, 'error');
                    }

                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                }
            } catch (error) {
                console.error('Error sending clock out request:', error);
                showNotification('An error occurred while trying to clock out.', 'error');

                // Re-enable the button
                clockOutBtn.isProcessing = false;
                clockOutBtn.disabled = false;
            }
        });
    }

    // Event listeners using the generic handler
    if (startBreakBtn) {
        startBreakBtn.addEventListener('click', () => {
            console.log('Start Break button clicked');
            // First check if we're already on break
            const currentStatus = statusTextElement.textContent.toLowerCase();
            if (currentStatus.includes('on break')) {
                console.log('Already on break');
                showNotification('You are already on break.', 'warning');
                return;
            }

            handleTimesheetAction('start-break', 'Break started successfully!', 'Failed to start break');
        });
    }

    if (endBreakBtn) {
        endBreakBtn.addEventListener('click', () => {
            console.log('End Break button clicked');
            // First check if we're actually on break
            const currentStatus = statusTextElement.textContent.toLowerCase();
            if (!currentStatus.includes('on break')) {
                console.log('Not on break');
                showNotification('You are not currently on break.', 'warning');
                return;
            }

            handleTimesheetAction('end-break', 'Break ended successfully!', 'Failed to end break');
        });
    }
    if (startUnavailableBtn) {
        startUnavailableBtn.addEventListener('click', () => handleTimesheetAction('start-unavailable', 'Marked as unavailable!', 'Failed to mark as unavailable'));
    }
    if (endUnavailableBtn) {
        endUnavailableBtn.addEventListener('click', () => handleTimesheetAction('end-unavailable', 'Marked as available!', 'Failed to mark as available'));
    }

});
</script>

<!-- Additional styles for tooltips and hours display -->
<style>
    /* Info icon tooltip */
    .fa-info-circle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.8rem;
        margin-left: 5px;
        cursor: help;
        transition: color 0.2s ease;
    }

    .fa-info-circle:hover {
        color: var(--accent-color);
    }

    /* Hours display styles */
    .hours-display {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-bottom: 10px;
    }

    .hours-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .hours-label {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.8);
    }

    .hours-value {
        font-size: 1.2rem;
        font-weight: 600;
        color: white;
    }

    /* Status badge styles */
    .status-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: 500;
        text-transform: capitalize;
        background-color: #ccc;
        color: #333;
    }

    .status-badge.active {
        background-color: #4CAF50;
        color: white;
    }

    .status-badge.submitted {
        background-color: #2196F3;
        color: white;
    }

    .status-badge.on_break {
        background-color: #FF9800;
        color: white;
    }

    .status-badge.unavailable {
        background-color: #F44336;
        color: white;
    }

    .status-badge.completed {
        background-color: #9C27B0;
        color: white;
    }

    /* No entries message */
    .no-entries {
        text-align: center;
        padding: 20px;
        color: #777;
        font-style: italic;
    }

    /* Timesheet table styles */
    .timesheet-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .timesheet-table th {
        background-color: var(--header-bg-color, #f5f5f5);
        color: var(--header-text-color, #333);
        padding: 12px 15px;
        text-align: left;
        font-weight: 600;
        border-bottom: 1px solid var(--border-color, #ddd);
    }

    .timesheet-table td {
        padding: 10px 15px;
        border-bottom: 1px solid var(--border-color, #eee);
        color: var(--text-color, #333);
    }

    .timesheet-table tr:last-child td {
        border-bottom: none;
    }

    .timesheet-table tr:hover {
        background-color: var(--row-hover-color, rgba(0, 0, 0, 0.02));
    }

    /* Dark mode adjustments */
    @media (prefers-color-scheme: dark) {
        .timesheet-table {
            background-color: var(--card-bg-color, #2a2a2a);
        }

        .timesheet-table th {
            background-color: var(--header-bg-color, #333);
            color: var(--header-text-color, #fff);
            border-bottom: 1px solid var(--border-color, #444);
        }

        .timesheet-table td {
            border-bottom: 1px solid var(--border-color, #333);
            color: var(--text-color, #eee);
        }

        .timesheet-table tr:hover {
            background-color: var(--row-hover-color, rgba(255, 255, 255, 0.05));
        }
    }
</style>
</body>
</html>
